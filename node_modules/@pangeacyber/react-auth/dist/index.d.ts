import { FC, ReactNode } from 'react';
import AuthNClient$1 from '@src/AuthNClient';
import { AuthConfig, AppState, AuthUser, APIResponse, CallbackParams, ClientResponse } from '@src/types';
export { APIResponse, AppState, AuthConfig, AuthUser, CallbackParams, ClientResponse, Profile, Token } from '@src/types';
export { CookieOptions } from '@src/shared/types';
export { getTokenFromCookie } from '@src/shared/session';

interface CookieOptions {
    /**
     * useCookie: optional boolean
     *
     * Option for using a cookie to keep the auth token around.
     * Default is false.
     *
     * When useCookie is false, all other CookieOptions are ignored,
     * and we will use localStorage instead of sessionStorage to keep
     * the auth token around.
     */
    useCookie: boolean;
    /**
     * cookieMaxAge: optional number (in seconds)
     *
     * This sets the max-age on the cookie (in seconds). Will only be used
     * if useCookie is true.
     *
     * Defaults to 48 hours.
     */
    cookieMaxAge?: number;
    /**
     * cookieName: optional string
     *
     * The name to be used when setting/getting the user token cookie.
     *
     * Defaults to "pangea-token" if not set.
     */
    cookieName?: string;
    /**
     * refreshCookieName: optional strinal
     *
     * The name to be used when setting/getting the refresh token cookie.
     *
     * Defaults to "pangea-refresh" if not set.
     */
    refreshCookieName?: string;
    /**
     * cookieDomain: optional string
     *
     * The domain to set on the cookie.
     */
    cookieDomain?: string;
}

interface AuthProviderProps {
    /**
     * loginUrl: string
     *
     * The url for the authn hosted UI
     */
    loginUrl: string;
    /**
     * The client config for the authn API
     *
     * See AuthConfig in types.ts for full
     * config options.
     */
    config: AuthConfig;
    /**
     * onLogin: (appState: AppState) => void
     *
     * Optional callback, called when successfully
     * logging in
     */
    onLogin?: (appState: AppState) => void;
    /**
     * cookieOptions: optional options used when setting a cookie for auth
     */
    cookieOptions?: CookieOptions;
    /**
     * redirectPathname: optional string
     *
     * When passed in, <AuthProvider /> will append this pathname to the
     * redirect URI when going through the login/logout flow
     *
     * @example
     * redirectPathname="/docs/"
     */
    redirectPathname?: string;
    /**
     * redirectOnLogout: optional boolean
     *
     * When set to true users will be redirected to the hosted logout page on logout.
     *
     * Default is false
     */
    redirectOnLogout?: boolean;
    /**
     * useStrictStateCheck: optional boolean
     *
     * When set to true AuthProvider will only accept state values generated by your application.
     *
     * Not allowing authentication flows starting from outside your application.
     *
     * Default is true
     */
    useStrictStateCheck?: boolean;
    children: JSX.Element;
}
interface AuthContextType {
    loading: boolean;
    authenticated: boolean;
    error: string;
    user: AuthUser | undefined;
    client: AuthNClient$1;
    login: () => void;
    logout: () => void;
    getToken: () => string | undefined;
}
declare const AuthProvider: FC<AuthProviderProps>;
declare const useAuth: () => AuthContextType;

interface ComponentAuthProviderProps {
    config: AuthConfig;
    cookieOptions?: CookieOptions;
    children: JSX.Element;
}
interface ComponentAuthContextType {
    authenticated: boolean;
    loading: boolean;
    error: APIResponse | undefined;
    user?: AuthUser;
    cbParams?: CallbackParams;
    client: AuthNClient$1;
    logout: () => void;
    getToken: () => string | undefined;
    setFlowComplete: (data: any) => void;
}
declare const ComponentAuthProvider: FC<ComponentAuthProviderProps>;
declare const useComponentAuth: () => ComponentAuthContextType;

declare class AuthNClient {
    config: AuthConfig;
    constructor(config: AuthConfig, useJwt?: boolean);
    logout(userToken: string): Promise<ClientResponse>;
    validate(userToken: string): Promise<ClientResponse>;
    userinfo(code: string): Promise<ClientResponse>;
    refresh(userToken: string, refreshToken: string): Promise<ClientResponse>;
    jwks(): Promise<ClientResponse>;
    post(endpoint: string, payload: any): Promise<ClientResponse>;
    getUrl(endpoint: string): string;
    getOptions(): any;
    getError(error: any): APIResponse;
}

interface AuthNFlowOptions {
    signin?: boolean;
    signup?: boolean;
}
interface FlowStorage {
    step?: FlowStep;
    flow_id?: string;
    email?: string;
    selected_mfa?: string;
    mfa_providers?: string[];
    recaptcha_key?: string;
    qr_code?: string;
}
declare enum FlowStep {
    START = "start",
    SIGNUP = "signup",
    SIGNUP_PASSWORD = "signup/password",
    SIGNUP_SOCIAL = "signup/social",
    VERIFY_SOCIAL = "verify/social",
    VERIFY_PASSWORD = "verify/password",
    VERIFY_CAPTCHA = "verify/captcha",
    VERIFY_EMAIL = "verify/email",
    ENROLL_MFA_SELECT = "enroll/mfa/select",
    ENROLL_MFA_START = "enroll/mfa/start",
    ENROLL_MFA_COMPLETE = "enroll/mfa/complete",
    VERIFY_MFA_SELECT = "verify/mfa/select",
    VERIFY_MFA_START = "verify/mfa/start",
    VERIFY_MFA_COMPLETE = "verify/mfa/complete",
    RESET_PASSWORD = "reset/password",
    MFA_SELECT = "mfa/select",
    COMPLETE = "complete"
}
interface FlowState {
    step?: FlowStep;
    flowId?: string;
    email?: string;
    selectedMfa?: string;
    mfaProviders?: string[];
    cancelMfa?: boolean;
    recaptchaKey?: string;
    qrCode?: string;
    passwordSignup?: boolean;
    socialSignup?: any;
    verifyProvider?: any;
    redirectUri?: string;
}
interface FlowStart {
    email?: string;
}
interface FlowBase {
    flowId?: string;
}
interface FlowSignupPassword extends FlowBase {
    firstName: string;
    lastName: string;
    password: string;
}
interface FlowVerifyPassword extends FlowBase {
    password?: string;
    reset?: string;
}
interface FlowVerifyCallback extends FlowBase {
    cbCode: string;
    cbState: string;
}
interface FlowVerifyCaptcha extends FlowBase {
    captchaCode: string;
}
interface FlowMfaStart extends FlowBase {
    mfaProvider: string;
    phoneNumber?: string;
}
interface FlowMfaComplete extends FlowBase {
    code?: string;
    mfaProvider?: string;
    cancel?: boolean;
}
interface FlowResetPassword extends FlowBase {
    password?: string;
    cbCode?: string;
    cbState?: string;
    cancel?: boolean;
}

declare class AuthNFlowClient extends AuthNClient$1 {
    state: FlowState;
    options: AuthNFlowOptions;
    constructor(config: AuthConfig, options?: AuthNFlowOptions);
    initState(flowState: FlowState): void;
    start(data: FlowStart): Promise<ClientResponse>;
    signupPassword(data: FlowSignupPassword): Promise<ClientResponse>;
    signupSocial(data: FlowVerifyCallback): Promise<ClientResponse>;
    verifySocial(data: FlowVerifyCallback): Promise<ClientResponse>;
    verifyPassword(data: FlowVerifyPassword): Promise<ClientResponse>;
    verifyCaptcha(data: FlowVerifyCaptcha): Promise<ClientResponse>;
    verifyEmail(data: FlowVerifyCallback): Promise<ClientResponse>;
    enrollMfaStart(data: FlowMfaStart): Promise<ClientResponse>;
    enrollMfaComplete(data: FlowMfaComplete): Promise<ClientResponse>;
    verifyMfaStart(data: FlowMfaStart): Promise<ClientResponse>;
    verifyMfaComplete(data: FlowMfaComplete): Promise<ClientResponse>;
    resetPassword(data: FlowResetPassword): Promise<ClientResponse>;
    complete(): Promise<ClientResponse>;
    reset(): void;
    post(endpoint: string, payload: any, updateState?: boolean): Promise<ClientResponse>;
    processResponse(response: APIResponse, updateState?: boolean): boolean;
}

interface AuthFlowContextType {
    step?: FlowStep;
    error: APIResponse | undefined;
    loading: boolean;
    flowData: FlowState;
    callNext: (endpoint: FlowStep, data: any) => void;
    reset: () => void;
    cbParams?: CallbackParams;
}
interface AuthFlowProviderProps {
    children: ReactNode;
}
declare const AuthFlowProvider: FC<AuthFlowProviderProps>;
declare const useAuthFlow: () => AuthFlowContextType;

declare const hasAuthParams: (searchParams?: string) => boolean;

declare const encode58: (source: any) => string;
declare const toUrlEncoded: (obj: {
    [key: string]: string;
}) => string;

export { AuthFlowProvider, AuthNClient, AuthNFlowClient, AuthNFlowOptions, AuthProvider, ComponentAuthProvider, FlowMfaComplete, FlowMfaStart, FlowSignupPassword, FlowStart, FlowState, FlowStep, FlowStorage, FlowVerifyCallback, FlowVerifyCaptcha, FlowVerifyPassword, encode58, hasAuthParams, toUrlEncoded, useAuth, useAuthFlow, useComponentAuth };
